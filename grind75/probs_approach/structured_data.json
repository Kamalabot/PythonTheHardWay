{"binary-search-tree": [{"slug": "lowest-common-ancestor-of-a-binary-search-tree", "challenge": "Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.\nAccording to the definition of LCA on Wikipedia:\nThe lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).", "approach": "To find the lowest common ancestor (LCA) of two nodes in a binary search tree (BST), we can follow these steps:\n\n1. Start from the root node of the BST.\n2. Compare the values of the root node with the values of the two given nodes, p and q.\n3. If both p and q are smaller than the value of the root node, move to the left subtree of the root node.\n4. If both p and q are greater than the value of the root node, move to the right subtree of the root node.\n5. If one node is smaller and the other node is greater than the value of the root node, or if one of the nodes is equal to the value of the root node, then the root node is the LCA.\n6. Repeat steps 2-5 until we find the LCA or reach a leaf node.\n7. Return the LCA node.\n\nThe reasoning behind this approach is that in a binary search tree, all nodes in the left subtree of a node will have values smaller than the node, and all nodes in the right subtree will have values greater than the node. So, by comparing the values of the given nodes with the root node at each step, we can narrow down the search for the LCA.", "url": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree", "commented": false}, {"slug": "validate-binary-search-tree", "challenge": "Given the root of a binary tree, determine if it is a valid binary search tree (BST).\nA valid BST is defined as follows:\nThe left subtree of a node contains only nodes with keys less than the node's key.\nThe right subtree of a node contains only nodes with keys greater than the node's key.\nBoth the left and right subtrees must also be binary search trees.", "approach": "Approach:\n1. Perform an inorder traversal on the binary tree.\n2. While traversing the tree, keep track of the previous node.\n3. Compare the current node value with the previous node value.\n4. If the current node's value is less than or equal to the previous node's value, return false.\n5. If the inorder traversal completes without any violation, return true.\n6. This approach ensures that the left subtree contains only nodes with keys less than the current node's key,\n   and the right subtree contains only nodes with keys greater than the current node's key.\n   It also checks that both the left and right subtrees are binary search trees.", "url": "https://leetcode.com/problems/validate-binary-search-tree", "commented": false}, {"slug": "kth-smallest-element-in-a-bst", "challenge": "Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.", "approach": "Approach:\n\n1. Perform an in-order traversal of the binary search tree.\n2. Maintain a counter to keep track of the number of nodes visited.\n3. When visiting each node during the traversal, increment the counter.\n4. If the counter is equal to k, return the value of that node as the kth smallest value.\n5. Continue the traversal until all nodes have been visited.\n6. If there are fewer than k nodes in the tree, return -1 or any appropriate indication to denote that the kth smallest value does not exist in the tree.\n\nExplanation:\n1. An in-order traversal of a binary search tree visits the nodes in ascending order.\n2. By incrementing the counter during the traversal, we can keep track of the number of nodes visited so far.\n3. Once the counter is equal to k, we know that we have found the kth smallest value.\n4. Returning -1 or any appropriate indication when there are fewer than k nodes ensures that we handle cases where the kth smallest value does not exist in the tree.", "url": "https://leetcode.com/problems/kth-smallest-element-in-a-bst", "commented": false}], "binary-tree": [{"slug": "invert-binary-tree", "challenge": "Given the root of a binary tree, invert the tree, and return its root.", "approach": "Approach:\n- Recursively swap the left and right children of each node in the binary tree.\n    - If the root is null, return null.\n    - Swap the left and right children of the root.\n    - Recursively invert the left subtree.\n    - Recursively invert the right subtree.\n- Return the root of the inverted tree.\n\nExplanation:\n- Recursive approach is used as it simplifies the problem by breaking it down into smaller subproblems.\n- Inverting a binary tree means swapping the left and right children of each node.\n- By swapping the children recursively from the root to the leaves, the entire tree gets inverted.\n- Null nodes are handled by returning null.\n- The inversion process starts from the root and propagates down to the leaves.", "url": "https://leetcode.com/problems/invert-binary-tree", "commented": false}, {"slug": "balanced-binary-tree", "challenge": "Given a binary tree, determine if it is height-balanced.\nA height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.", "approach": "To determine if a binary tree is height-balanced, we can use a recursive approach as follows:\n\n1. Create a helper function `getHeight` that takes a root node as input and returns the height of the tree rooted at that node:\n\n    - If the node is null, return 0.\n    - Otherwise, return 1 plus the maximum height of its left and right subtrees, obtained recursively by calling `getHeight` on its left and right child nodes.\n\n2. Create a function `isBalanced` that takes a root node as input and returns a boolean value indicating whether the tree rooted at that node is height-balanced:\n\n    - If the root node is null, return true (an empty tree is considered height-balanced).\n    - Otherwise, check if the absolute difference in height between the left and right subtrees of the root node is less than or equal to 1. If not, return false.\n    - Recursively call `isBalanced` on the left and right child nodes to check if their subtrees are height-balanced as well. If any of the recursive calls returns false, return false.\n    - If all recursive calls return true, return true.\n\n3. In the main function, call `isBalanced` with the root node of the given binary tree and return the result.\n\nThe approach is based on the definition of a height-balanced tree, which states that the depth of the two subtrees of every node should never differ by more than one. By recursively checking the balance of each node and its subtrees, we can determine if the entire tree is height-balanced.", "url": "https://leetcode.com/problems/balanced-binary-tree", "commented": false}, {"slug": "diameter-of-binary-tree", "challenge": "Given the root of a binary tree, return the length of the diameter of the tree.\nThe diameter of a binary tree is the length of the longest path between any two nodes in a tree.\nThis path may or may not pass through the root.\nThe length of a path between two nodes is represented by the number of edges between them.", "approach": "Approach:\n1. We need to find the length of the longest path between any two nodes in the binary tree.\n2. The diameter of the binary tree can either pass through the root or not.\n3. To find the longest path that passes through the root, we need to find the height of the left subtree and the right subtree and add them together.\n4. To find the longest path that does not pass through the root, we need to find the diameter of the left subtree and the diameter of the right subtree, and take the maximum between them.\n5. Recursively calculate the height and diameter of the subtree until we reach the leaf nodes.\n6. At each node, update the maximum diameter if the current diameter is greater than the maximum diameter found so far.\n7. Return the maximum diameter of the binary tree.", "url": "https://leetcode.com/problems/diameter-of-binary-tree", "commented": false}, {"slug": "maximum-depth-of-binary-tree", "challenge": "Given the root of a binary tree, return its maximum depth.\nA binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.", "approach": "Approach:\n- If the root is null, return 0 (base case).\n- Otherwise, recursively calculate the maximum depth of the left and right subtrees of the root.\n- Return the maximum depth of the subtree plus 1 (for the root).\n- The depth of a subtree is the maximum depth of its left and right subtrees, plus 1.", "url": "https://leetcode.com/problems/maximum-depth-of-binary-tree", "commented": false}, {"slug": "binary-tree-level-order-traversal", "challenge": "Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).", "approach": "To solve this problem, we can use a Breadth First Search (BFS) algorithm. The approach is as follows:\n\n1. Create an empty queue and add the root to the queue.\n2. Create an empty list to store the level order traversal.\n3. While the queue is not empty:\n   - Get the current size of the queue to determine the number of nodes in the current level.\n   - Create a new list to store the nodes in the current level.\n   - Iterate through the nodes in the current level:\n     - Remove the first node from the queue.\n     - Add the value of the current node to the list for the current level.\n     - Add the left and right children of the current node to the queue if they exist.\n   - Add the list for the current level to the level order traversal list.\n4. Return the level order traversal list.\n\nThe BFS algorithm ensures that we process the nodes in a level-by-level order, starting from the root. By keeping track of the size of the queue at each level, we can identify the nodes in the current level and add their values to the traversal list.", "url": "https://leetcode.com/problems/binary-tree-level-order-traversal", "commented": false}, {"slug": "lowest-common-ancestor-of-a-binary-tree", "challenge": "Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\nAccording to the definition of LCA on Wikipedia:\nThe lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).", "approach": "Approach:\n1. Start at the root of the tree.\n2. Traverse the tree using a depth-first search (DFS) approach.\n3. During traversal, keep track of the parent-child relationship by storing the parent of each node.\n4. When the traversal reaches one of the given nodes (p or q), stop and return the node.\n5. Repeat the traversal process for the other node.\n6. Once both nodes have been found, compare their parent nodes iteratively until a common parent is found.\n7. Return the common parent as the lowest common ancestor.", "url": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree", "commented": false}, {"slug": "binary-tree-right-side-view", "challenge": "Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.", "approach": "Approach:\n1. Initialize an empty list to store the visible nodes.\n2. Use a depth-first search (DFS) traversal to explore the tree.\n3. For each level of the tree, add the value of the rightmost node to the list of visible nodes. \n   - This can be done by checking if the current depth is equal to the length of the visible nodes list.\n   - If it is, add the value of the current node to the visible nodes list.\n4. Recursively traverse the right subtree first and then the left subtree.\n   - This ensures that the rightmost node of each level is added to the visible nodes list.\n   - This order of traversal is important because we want to see the rightmost node first.\n5. Return the list of visible nodes at the end of the traversal.", "url": "https://leetcode.com/problems/binary-tree-right-side-view", "commented": false}, {"slug": "construct-binary-tree-from-preorder-and-inorder-traversal", "challenge": "Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.", "approach": "One possible approach to solve this problem is as follows:\n1. Create a recursive function `buildTree` that takes the `preorder` and `inorder` arrays as parameters, as well as two additional parameters `preStart` and `preEnd` that represent the current range of the preorder array being processed.\n2. If `preStart > preEnd`, return `null` since there are no more elements in the subtree.\n3. Create a new TreeNode object with its value set to the element at index `preStart` in the `preorder` array.\n4. Find the index `inIndex` of the same element in the `inorder` array.\n5. Calculate the length `leftLen` of the left subtree by subtracting `inIndex` from `inStart`.\n6. Recursively call `buildTree` to construct the left subtree by passing the updated `preStart`, `preStart + leftLen`, `inStart`, and `inIndex - 1` as parameters.\n7. Recursively call `buildTree` to construct the right subtree by passing `preStart + leftLen + 1`, `preEnd`, `inIndex + 1`, and `inEnd` as parameters.\n8. Set the left and right children of the current TreeNode to the return values of the recursive function calls from steps 6 and 7, respectively.\n9. Return the current TreeNode.\n10. Initially call the `buildTree` function with the `preorder` and `inorder` arrays, and the range of the entire arrays as parameters. This will start the construction process and return the root of the binary tree.", "url": "https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal", "commented": false}, {"slug": "serialize-and-deserialize-binary-tree", "challenge": "Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\nDesign an algorithm to serialize and deserialize a binary tree.\nThere is no restriction on how your serialization/deserialization algorithm should work.\nYou just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.\nClarification: The input/output format is the same as how LeetCode serializes a binary tree.\nYou do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.", "approach": "Approach:\n\n1. Serialization:\n   - Perform a pre-order traversal of the binary tree.\n   - For each node, append its value to the serialized string.\n   - If the node is a leaf, append a marker (null or a specific character) to indicate that it is a leaf node.\n   - Return the serialized string.\n\n2. Deserialization:\n   - Split the serialized string by a delimiter to get an array of values.\n   - Create a queue to hold the nodes during deserialization.\n   - Initialize an index variable to keep track of the current node value in the array.\n   - Create the root node using the first value in the array.\n   - Add the root node to the queue.\n   - Iterate over the remaining values in the array:\n     - If the value is not a marker, create a new node with the value and link it to its parent node (the first node in the queue).\n     - If the value is a marker, set the parent node's left or right child to null (indicating a leaf node).\n     - Add the new node to the queue.\n     - Increment the index variable.\n   - Return the root node of the deserialized binary tree.\n\nExplanation:\n- The pre-order traversal is used for serialization as it allows us to reconstruct the binary tree using only the serialized string.\n- A marker is used to indicate a leaf node because we need to differentiate between a leaf node and a null value in the serialized string.\n- During deserialization, a queue is used to keep track of the parents of the nodes being created. This helps in linking the nodes correctly.\n- The index variable is used to keep track of the current node value in the serialized string array. It is incremented after each node is created and linked to its parent.", "url": "https://leetcode.com/problems/serialize-and-deserialize-binary-tree", "commented": false}], "matrix": [{"slug": "spiral-matrix", "challenge": "Given an m x n matrix, return all elements of the matrix in spiral order.", "approach": "To solve this problem, we can use a simulation approach. We will keep track of the boundaries of the matrix and simulate the spiral traversal by iterating over the elements in a clockwise direction.\n\n1. Initialize four variables: top, bottom, left, and right, to represent the boundaries of the matrix. Set top = 0, bottom = m - 1, left = 0, and right = n - 1.\n\n2. Initialize an empty result list to store the elements of the matrix in spiral order.\n\n3. Iterate while top <= bottom and left <= right:\n   - Iterate from left to right, appending each element matrix[top][i] to the result list. Increment top by 1.\n   - Iterate from top to bottom, appending each element matrix[i][right] to the result list. Decrement right by 1.\n   - Check if top <= bottom and left <= right:\n      - Iterate from right to left, appending each element matrix[bottom][i] to the result list. Decrement bottom by 1.\n      - Iterate from bottom to top, appending each element matrix[i][left] to the result list. Increment left by 1.\n\n4. After the above loop, the result list will contain all the elements of the matrix in spiral order. Return the result list.\n\nThis approach works by moving along the boundaries of the matrix in a clockwise direction. We start by traversing the top row, then the right column, then the bottom row (if applicable), and finally the left column (if applicable). We repeat this process until we have traversed all the elements in the matrix. By updating the boundaries after each traversal, we ensure that we do not revisit any element.", "url": "https://leetcode.com/problems/spiral-matrix", "commented": false}], "string": [{"slug": "valid-palindrome", "challenge": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters\nit reads the same forward and backward. Alphanumeric characters include letters and numbers.\nGiven a string s, return true if it is a palindrome, or false otherwise.", "approach": "To approach this problem, we can follow these steps:\n1. Convert the string to lowercase using string's built-in method `toLowerCase()`.\n2. Remove all non-alphanumeric characters using regular expressions or iterating through the string character by character.\n3. Compare the modified string with its reverse, either by iterating through the characters or using string's built-in method `reverse()`.\n4. Return true if the modified string is equal to its reverse, otherwise return false.\n\nNote: It is important to remove non-alphanumeric characters before checking for palindrome to ensure accurate comparison.", "url": "https://leetcode.com/problems/valid-palindrome", "commented": false}, {"slug": "valid-anagram", "challenge": "Given two strings s and t, return true if t is an anagram of s, and false otherwise.\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.", "approach": "Approach:\n1. Check if the lengths of the two strings are equal. If not, return false as they cannot be anagrams.\n2. Create two hash tables (or arrays) to store the frequency of each character in both strings.\n3. Traverse through each character in the first string and update the frequency in the first hash table.\n4. Traverse through each character in the second string and update the frequency in the second hash table.\n5. Compare the two hash tables (or arrays) element by element. If any frequency is different, return false.\n6. If all frequencies are the same, return true as the two strings are anagrams.", "url": "https://leetcode.com/problems/valid-anagram", "commented": false}, {"slug": "longest-palindrome", "challenge": "Given a string s which consists of lowercase or uppercase letters, return the length of the longest palindrome that can be built with those letters.\nLetters are case sensitive, for example, 'Aa' is not considered a palindrome here.", "approach": "One approach to solve this problem is by using a hash map to count the frequency of each letter in the given string. \n\n1. Initialize an empty hash map to store the frequency of each letter.\n2. Iterate through each character in the string.\n3. For each character, check if it exists in the hash map. If it does, increment its frequency by 1. If it doesn't, add it to the hash map with a frequency of 1.\n4. Initialize a variable called maxLength to store the length of the longest palindrome. Set it to 0 initially.\n5. Initialize a boolean variable called hasOddFrequency to check if there is any character with an odd frequency. Set it to false initially.\n6. Iterate through each character in the hash map.\n7. For each character, check its frequency. If the frequency is even, add it to the maxLength. If the frequency is odd, add it to the maxLength minus 1 (to make it even). Set hasOddFrequency to true.\n8. If hasOddFrequency is true, add 1 to the maxLength (to account for a single character with an odd frequency).\n9. Return the maxLength as the length of the longest palindrome.", "url": "https://leetcode.com/problems/longest-palindrome", "commented": false}, {"slug": "longest-substring-without-repeating-characters", "challenge": "Given a string s, find the length of the longest substring without repeating characters.\nA substring is a contiguous non-empty sequence of characters within a string.", "approach": "Approach:\n1. Initialize variables max_len and start to 0.\n2. Create an empty dictionary to store the last seen index of each character.\n3. Iterate through the string s using a for loop, with index i.\n4. If the current character s[i] is already present in the dictionary and its last seen index is greater than or equal to start, update the start variable to the last seen index + 1.\n   This is done to reset the starting point of the substring to the next index after the repeated character.\n5. Update the last seen index of the current character in the dictionary.\n6. Calculate the current length of the substring by subtracting start from i + 1.\n7. Update the max_len variable if the current length is greater than max_len.\n8. Return max_len as the length of the longest substring without repeating characters.", "url": "https://leetcode.com/problems/longest-substring-without-repeating-characters", "commented": false}, {"slug": "string-to-integer-atoi", "challenge": "Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++'s atoi function).\nThe algorithm for myAtoi(string s) is as follows:\nRead in and ignore any leading whitespace.\nCheck if the next character (if not already at the end of the string) is '-' or '+'. Read this character in if it is either.\nThis determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.\nRead in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.\nConvert these digits into an integer (i.e. '123' -> 123, '0032' -> 32). If no digits were read, then the integer is 0. Change the sign as necessary (from step 2).\nIf the integer is out of the 32-bit signed integer range [-231, 231 - 1], then clamp the integer so that it remains in the range.\nSpecifically, integers less than -231 should be clamped to -231, and integers greater than 231 - 1 should be clamped to 231 - 1.\nReturn the integer as the final result.\nNote:\nOnly the space character ' ' is considered a whitespace character.\nDo not ignore any characters other than the leading whitespace or the rest of the string after the digits.", "approach": "1. Remove any leading whitespace from the input string.\n\n2. Check if the first non-whitespace character is '-' or '+'. If it is, set a flag to indicate the sign of the result.\n\n3. Read the digits from the string until a non-digit character is encountered or the end of the string is reached. Convert the digits into an integer as you go.\n\n4. If no digits were read, return 0.\n\n5. If the sign flag is set to indicate a negative result, multiply the integer by -1.\n\n6. If the integer is less than the minimum value of a 32-bit signed integer, set it to the minimum value.\n\n7. If the integer is greater than the maximum value of a 32-bit signed integer, set it to the maximum value.\n\n8. Return the integer as the final result.", "url": "https://leetcode.com/problems/string-to-integer-atoi", "commented": false}, {"slug": "longest-palindromic-substring", "challenge": "Given a string s, return the longest palindromic substring in s.", "approach": "One approach to solve this problem is to use the concept of dynamic programming.\n\nWe can create a 2D boolean table dp, where dp[i][j] will be true if the substring from index i to index j is a palindrome, and false otherwise.\n\nFirst, we need to initialize the diagonals of the dp table as true, as a single character is always a palindrome.\n\nNext, we can iterate through the characters of the string s in reverse order. For each character, we iterate through the characters that come after it. If the characters at indices i and j are the same and the substring from index i+1 to index j-1 is a palindrome, then we set dp[i][j] as true.\n\nAdditionally, we keep track of the starting and ending indices of the longest palindromic substring found so far.\n\nFinally, we can return the substring from the starting to the ending index of the longest palindromic substring.\n\nThe time complexity of this approach is O(n^2), where n is the length of the string s.", "url": "https://leetcode.com/problems/longest-palindromic-substring", "commented": false}, {"slug": "find-all-anagrams-in-a-string", "challenge": "Given two strings s and p, return an array of all the start indices of p's anagrams in s. You may return the answer in any order.\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.", "approach": "One approach to solving this problem is to use a sliding window technique.\n\n1. Create two arrays to keep track of the frequency of characters in the strings p and s. Initialize both arrays with zeros.\n2. Traverse through the string p and increment the count of each character in the p array.\n3. Initialize two pointers, left and right, both pointing to the start of the string s.\n4. While the right pointer is less than the length of the string s:\n   a. Increment the count of the character at the right pointer in the s array.\n   b. If the size of the window (right pointer - left pointer + 1) is equal to the length of p:\n         i. Check if the frequency arrays for s and p are equal.\n        ii. If they are equal, add the left pointer to the result list.\n       iii. Decrement the count of the character at the left pointer in the s array.\n        iv. Increment the left pointer to move the window.\n    c. Increment the right pointer to expand the window.\n5. Return the result list.\n\nThe sliding window technique is used here to maintain a fixed size window and check if the characters in the window form an anagram of p. We update the window by incrementing the count of characters at the right pointer and decrementing the count of characters at the left pointer. By checking the frequency arrays of s and p, we can determine if the window represents an anagram of p.", "url": "https://leetcode.com/problems/find-all-anagrams-in-a-string", "commented": false}, {"slug": "minimum-window-substring", "challenge": "Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window.\nIf there is no such substring, return the empty string.\nThe testcases will be generated such that the answer is unique.", "approach": "Approach:\n1. Create a hashmap to store the frequency of each character in string t.\n2. Initialize two pointers, start and end, to track the window substring in string s.\n3. Initialize variables, count (to keep track of the number of characters in t that are included in the window) and minLen (to keep track of the minimum window length found so far).\n4. Iterate through string s using the end pointer and update the frequency of each character in the hashmap.\n5. If the character's frequency in the hashmap is greater than 0, decrement count.\n6. If count is 0, it means that the current window substring contains all characters of t.\n   6.1 Update minLen if the current window length is smaller than minLen.\n   6.2 Remove characters from the start of the window (using the start pointer) until count becomes greater than 0.\n7. Return the minimum window substring found or an empty string if no such substring exists.\n\nExplanation:\n- We are using the sliding window technique to find the minimum window substring.\n- By keeping track of the frequency of characters in t, we can determine if a window substring of s contains all characters of t.\n- The hashmap allows us to efficiently update the frequencies of characters and determine if the count is 0.\n- The start pointer is used to remove characters from the window when we find a valid substring, ensuring that we keep the window as small as possible.", "url": "https://leetcode.com/problems/minimum-window-substring", "commented": false}], "dynamic-programming": [{"slug": "climbing-stairs", "challenge": "You are climbing a staircase. It takes n steps to reach the top.\nEach time you can either climb 1 or 2 steps.\nIn how many distinct ways can you climb to the top?", "approach": "To solve this problem, we can use dynamic programming. \n\n1. Create an array of size n+1 to store the number of distinct ways to climb to each step.\n2. Initialize the first two elements of the array as 1, as there is only one way to climb to the first and second step.\n3. Iterate through the array starting from the third element.\n4. For each step, the number of distinct ways to reach that step is the sum of the distinct ways to reach the previous two steps.\n   This is because you can either climb 1 step from the previous step or 2 steps from the step two steps before.\n5. Finally, the number of distinct ways to reach the top is the value at the last index of the array.\n6. Return the value at the last index of the array.\n\nBy breaking down the problem into smaller subproblems and using dynamic programming, we can avoid redundant calculations and compute the answer efficiently.", "url": "https://leetcode.com/problems/climbing-stairs", "commented": false}, {"slug": "maximum-subarray", "challenge": "Given an integer array nums, find the subarray with the largest sum, and return its sum.\nA subarray is a contiguous non-empty sequence of elements within an array.", "approach": "To solve this problem, we can use Kadane's algorithm. \n\n1. Initialize two variables, maxSum and currentSum, both set to the value of the first element in the array nums.\n2. Iterate through the array from the second element onwards.\n3. For each element, update the currentSum by adding the current element to it.\n4. If the currentSum is greater than the maxSum, update the maxSum to the currentSum.\n5. If the currentSum becomes negative, reset it to zero.\n   Explanation: If the currentSum becomes negative, it means that adding the current element to it will only decrease the sum. Therefore, it is better to start a new subarray from the next element.\n6. After iterating through the entire array, the maxSum will represent the sum of the largest subarray.\n7. Return the maxSum as the result.", "url": "https://leetcode.com/problems/maximum-subarray", "commented": false}, {"slug": "coin-change", "challenge": "You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\nReturn the fewest number of coins that you need to make up that amount.\nIf that amount of money cannot be made up by any combination of the coins, return -1.\nYou may assume that you have an infinite number of each kind of coin.", "approach": "Approach:\n1. Define an array dp of size (amount + 1) and initialize all its elements with a value greater than amount. This array will store the minimum number of coins required to make up each amount.\n2. Set dp[0] = 0 since no coins are needed to make up an amount of 0.\n3. Iterate through each coin denomination in the coins array.\n4. For each coin denomination, iterate through each amount from coin to amount.\n5. Calculate the minimum number of coins required to make up the current amount by subtracting the coin value from the current amount and adding 1 (to account for the current coin denomination).\n6. Update dp[amount] with the minimum number of coins if it is smaller than the current value stored in dp[amount].\n7. After iterating through all the coin denominations and amounts, check if dp[amount] is still greater than amount. If so, it means that the amount cannot be made up by any combination of coins, so return -1. Otherwise, return dp[amount] as the fewest number of coins required to make up the amount.", "url": "https://leetcode.com/problems/coin-change", "commented": false}, {"slug": "partition-equal-subset-sum", "challenge": "Given an integer array nums, return true if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or false otherwise", "approach": "One possible approach to solve this problem is by using dynamic programming.\n\n1. Calculate the sum of all the elements in the array.\n2. If the sum is odd, return false. It is not possible to partition the array into two subsets with equal sums if the total sum is not divisible by 2. (Explanation: in order for two subsets to have equal sums, the total sum must be even)\n3. Otherwise, create a boolean 2D array dp of size (nums.length + 1) x (sum/2 + 1). dp[i][j] will represent whether it is possible to achieve a sum of j using the first i elements of the array.\n4. Initialize the first column of dp (dp[:][0]) to true, since it is always possible to achieve a sum of 0 using any number of elements.\n5. Iterate through the elements of the array from 1 to nums.length and for each element nums[i], iterate through the possible sums from 1 to sum/2. For each sum j, dp[i][j] will be true if any of the following conditions are met:\n    - dp[i-1][j] is true (we can achieve the sum j without using the current element)\n    - j is greater than or equal to nums[i] and dp[i-1][j-nums[i]] is true (we can achieve the sum j by including the current element)\n6. At the end of the iteration, dp[nums.length][sum/2] will be true if it is possible to partition the array into two subsets with equal sums, and false otherwise.\n7. Return dp[nums.length][sum/2] as the result.", "url": "https://leetcode.com/problems/partition-equal-subset-sum", "commented": false}, {"slug": "unique-paths", "challenge": "There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]).\nThe robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\nGiven the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.\nThe test cases are generated so that the answer will be less than or equal to 2 * 109.", "approach": "To solve this problem, we can use dynamic programming.\n\n1. Create a 2D array dp of size m x n. Each element dp[i][j] represents the number of unique paths to reach the cell (i, j).\n\n2. Initialize the first row and first column of dp to 1 because there is only one way to reach any cell in the first row or column (by moving only right or down).\n\n3. Iterate over the remaining cells in the grid starting from (1, 1). For each cell (i, j), the number of unique paths to reach it is equal to the sum of the number of paths to reach the cell above it (dp[i-1][j]) and the cell to the left of it (dp[i][j-1]).\n\n4. Return dp[m-1][n-1], which represents the number of unique paths to reach the bottom-right corner.\n\nThe time complexity of this approach is O(m x n) because we need to compute the number of unique paths for each cell in the grid. The space complexity is also O(m x n) for the dp array.", "url": "https://leetcode.com/problems/unique-paths", "commented": false}], "graph": [{"slug": "flood-fill", "challenge": "An image is represented by an m x n integer grid image where image[i][j] represents the pixel value of the image.\nYou are also given three integers sr, sc, and color. You should perform a flood fill on the image starting from the pixel image[sr][sc].\nTo perform a flood fill, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color), and so on.\nReplace the color of all of the aforementioned pixels with color.\nReturn the modified image after performing the flood fill.", "approach": "Approach:\n1. Initialize a variable `originalColor` with the value of `image[sr][sc]`, which represents the color of the starting pixel.\n2. Initialize a queue and add the starting pixel coordinates (`sr`, `sc`) to it.\n3. Create a `visited` matrix of the same size as the image and initialize all values to `false`.\n4. While the queue is not empty, do the following steps:\n   - Dequeue a pixel from the queue and store its coordinates in `row` and `col` variables.\n   - Check if the pixel at `(row, col)` is already visited by checking `visited[row][col]`. If it is visited, skip to the next iteration of the loop.\n   - Mark the pixel at `(row, col)` as visited by setting `visited[row][col]` to `true`.\n   - Check if the color of the pixel at `(row, col)` is equal to `originalColor`. If it is not equal, skip to the next iteration of the loop.\n   - Set the color of the pixel at `(row, col)` to the `color` specified in the input.\n   - Enqueue the neighboring pixels (up, down, left, right) of `(row, col)` if they are within the image boundaries and have the same color as `originalColor`.\n5. Return the modified image after all pixels have been visited and their colors have been changed.", "url": "https://leetcode.com/problems/flood-fill", "commented": false}, {"slug": "01-matrix", "challenge": "Given an m x n binary matrix mat, return the distance of the nearest 0 for each cell.\nThe distance between two adjacent cells is 1.", "approach": "Approach:\n\n1. Create a result matrix of the same dimensions as the input matrix to store the distances of the nearest 0 for each cell.\n2. Initialize each cell in the result matrix to -1 as a placeholder for the distance.\n3. Iterate through the input matrix and for each cell with a value of 0:\n   - Set the corresponding cell in the result matrix to 0, as the distance to itself is 0.\n   - Enqueue the cell coordinates in a queue to start BFS from this cell.\n4. Perform a breadth-first search (BFS) traversal starting from each cell with a value of 0:\n   - Pop a cell from the queue and get its coordinates.\n   - Explore the neighboring cells (up, down, left, right) and for each valid neighbor with a distance of -1 in the result matrix, update its distance to the current cell's distance + 1.\n   - Enqueue the neighboring cells with updated distances.\n   - Repeat this process until the queue is empty.\n5. Return the result matrix.", "url": "https://leetcode.com/problems/01-matrix", "commented": false}, {"slug": "clone-graph", "challenge": "Given a reference of a node in a connected undirected graph.\nReturn a deep copy (clone) of the graph.\nEach node in the graph contains a value (int) and a list (List[Node]) of its neighbors.\nclass Node {\n public int val; \n public List<Node> neighbors;\n}", "approach": "To clone a connected undirected graph, we can use the depth-first search (DFS) algorithm.\n\n1. Create a hash map to store the mapping between each node in the original graph and its clone.\n2. Create a queue to perform breadth-first search (BFS) traversal of the original graph.\n3. Start BFS from the given reference node. Add the reference node to the queue.\n4. Create a clone of the reference node and add it to the hash map.\n5. While the queue is not empty, do the following:\n    - Remove the front node from the queue.\n    - For each neighbor of the current node:\n        - If the neighbor is not present in the hash map:\n            - Create a clone of the neighbor.\n            - Add the neighbor to the hash map.\n            - Add the neighbor to the queue.\n        - Add the clone of the neighbor to the clone of the current node's neighbor list.\n6. Return the clone of the reference node.\n\nBy using a hash map to keep track of the mapping between original nodes and their clones, we ensure that we create only one clone for each unique node in the original graph. This prevents duplication of nodes and creates a proper deep copy of the graph.", "url": "https://leetcode.com/problems/clone-graph", "commented": false}, {"slug": "course-schedule", "challenge": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1.\nYou are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\nFor example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\nReturn true if you can finish all courses. Otherwise, return false.", "approach": "Approach:\n\n1. Create an adjacency list to represent the dependencies between courses based on the prerequisites array. Each index i of the adjacency list will represent a course, and the value at that index will be a list of courses that must be taken before taking course i.\n2. Create a visited array to keep track of the visited courses during the depth-first search.\n3. Create a recursive function that performs a depth-first search starting from each course. If the current course is already visited, return false to indicate a cycle has been detected. If the current course is not visited, mark it as visited and recursively call the function for each course in its adjacency list.\n4. Return true if the depth-first search does not detect any cycles, indicating that all courses can be finished. Otherwise, return false indicating that there is a cycle and not all courses can be finished.", "url": "https://leetcode.com/problems/course-schedule", "commented": false}, {"slug": "number-of-islands", "challenge": "Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically.\nYou may assume all four edges of the grid are all surrounded by water.", "approach": "To solve this problem, we can use a depth-first search (DFS) approach. \n\n1. Iterate through each cell in the grid.\n2. If a cell contains '1', it is part of an island. Increment the count of islands by 1 and call a DFS function on that cell.\n3. In the DFS function, mark the current cell as visited by changing its value to '0'.\n4. Recursively call the DFS function on all four adjacent cells (up, down, left, right) that are within the grid boundaries and contain '1'.\n5. Mark each visited cell as '0' to prevent revisiting it in future iterations.\n6. Repeat steps 2-5 for all cells in the grid.\n7. Return the count of islands.\n\nThe DFS function helps to explore all the adjacent land cells connected to the current cell. By recursively visiting all adjacent land cells, we can identify the entire island.\n\nThe marking of cells as visited is necessary to avoid revisiting cells that have already been processed. This helps to prevent infinite loops and ensures that we visit each cell only once.", "url": "https://leetcode.com/problems/number-of-islands", "commented": false}, {"slug": "rotting-oranges", "challenge": "You are given an m x n grid where each cell can have one of three values:\n0 representing an empty cell,\n1 representing a fresh orange, or 2 representing a rotten orange.\nEvery minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.\nReturn the minimum number of minutes that must elapse until no cell has a fresh orange.\nIf this is impossible, return -1.", "approach": "To solve this problem, we can use Breadth-First Search (BFS) algorithm.\n\n1. Initialize a queue to store the coordinates of the rotten oranges.\n2. Initialize a variable to keep track of the number of fresh oranges.\n3. Iterate through the grid and do the following:\n   - If the cell contains a rotten orange, add its coordinates to the queue.\n   - If the cell contains a fresh orange, increment the count of fresh oranges.\n4. If there are no fresh oranges, return 0 (no minutes needed).\n5. Initialize a variable to keep track of the number of minutes that have elapsed.\n6. While the queue is not empty, do the following:\n   - Initialize a variable to keep track of the number of newly rotten oranges in the current minute.\n   - Iterate through the oranges in the queue (rotten oranges in the current minute) and do the following:\n     - For each orange, check its four neighboring cells (top, bottom, left, right):\n       - If a neighboring cell contains a fresh orange, change its value to rotten (2) and add its coordinates to the queue.\n       - Decrement the count of fresh oranges.\n   - If there were no newly rotten oranges, break the loop (no further minutes needed).\n   - Increment the number of minutes that have elapsed.\n7. If there are still fresh oranges remaining, return -1 (impossible).\n8. Otherwise, return the number of minutes that have elapsed.", "url": "https://leetcode.com/problems/rotting-oranges", "commented": false}, {"slug": "accounts-merge", "challenge": "Given a list of accounts where each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, and the rest of the elements are emails representing emails of the account.\nNow, we would like to merge these accounts.\nTwo accounts definitely belong to the same person if there is some common email to both accounts.\nNote that even if two accounts have the same name, they may belong to different people as people could have the same name.\nA person can have any number of accounts initially, but all of their accounts definitely have the same name.\nAfter merging the accounts, return the accounts in the following format:\nthe first element of each account is the name, and the rest of the elements are emails in sorted order.\nThe accounts themselves can be returned in any order.", "approach": "To solve this problem, we can use the Union-Find algorithm.\n1. Create a dictionary to store the mapping of each email to its parent email. Initialize the parent of each email as itself.\n2. Create a dictionary to store the mapping of each email to its corresponding name. We can iterate through the accounts to populate this dictionary.\n3. Iterate through each account and for each email in the account:\n   - Find the parent email of the current email using the parent dictionary.\n   - Union the current email with the parent email by updating the parent dictionary.\n4. Create a dictionary to store the mapping of each parent email to a list of emails. Iterate through each email and add it to the corresponding parent email's list in this dictionary.\n5. Iterate through the dictionary created in step 4 and for each parent email:\n   - Retrieve the corresponding name from the name dictionary.\n   - Sort the list of emails for the current parent email.\n   - Append the sorted list of emails to a new list, with the name as the first element.\n6. Return the new list of accounts.", "url": "https://leetcode.com/problems/accounts-merge", "commented": false}, {"slug": "word-search", "challenge": "Given an m x n grid of characters board and a string word, return true if word exists in the grid.\nThe word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring.\nThe same letter cell may not be used more than once.", "approach": "One possible approach to solve this problem is to use backtracking.\n\n1. Iterate through each cell in the grid.\n2. For each cell, perform a depth-first search (DFS) to check if the word can be formed starting from that cell.\n3. In the DFS, check if the current cell matches the first character of the word. If not, return false.\n4. If the current cell matches the first character of the word, mark it as visited or change the value to a special character to indicate that it has been visited.\n5. Recursively check if the word can be formed by exploring the neighboring cells (up, down, left, and right). \n6. If the recursion returns true, return true.\n7. If the recursion returns false, backtrack by unmarking the current cell as visited or changing its value back to the original value.\n8. Continue step 3-7 until all cells have been checked.\n9. If no cell returns true from the DFS, return false.\n\nThe backtracking approach efficiently explores all possible paths in the grid, avoiding revisiting the same cell, making it an effective solution for this problem.", "url": "https://leetcode.com/problems/word-search", "commented": false}, {"slug": "minimum-height-trees", "challenge": "A tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.\nGiven a tree of n nodes labelled from 0 to n - 1, and an array of n - 1 edges where edges[i] = [ai, bi] indicates that there is an undirected edge between the two nodes ai and bi in the tree, you can choose any node of the tree as the root.\nWhen you select a node x as the root, the result tree has height h.\nAmong all possible rooted trees, those with minimum height (i.e. min(h))  are called minimum height trees (MHTs).\nReturn a list of all MHTs' root labels. You can return the answer in any order.\nThe height of a rooted tree is the number of edges on the longest downward path between the root and a leaf.", "approach": "To solve the problem, we can use a topological sorting approach. \n\n1. First, we need to construct an adjacency list representation of the tree based on the given edges.\n\n2. Next, we can start by finding all the leaf nodes (nodes with only one neighbor) and removing them from the graph. \n\n3. After removing the leaf nodes, new leaf nodes may be formed. Repeat step 2 until there are only 1 or 2 nodes left in the graph. These nodes will be the roots of the MHTs.\n\n4. Finally, return the remaining nodes as the root labels of the MHTs.", "url": "https://leetcode.com/problems/minimum-height-trees", "commented": false}, {"slug": "word-ladder", "challenge": "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\nEvery adjacent pair of words differs by a single letter.\nEvery si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.\nsk == endWord\nGiven two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.", "approach": "To solve this problem, we can use a variation of Breadth First Search (BFS) algorithm.\n\n1. Create a queue and enqueue the beginWord.\n2. Create a visited set and add the beginWord to it.\n3. Create a distance map and set the distance of beginWord to 0.\n4. While the queue is not empty:\n    - Dequeue a word from the queue.\n    - Find all the words in the wordList that are one letter different from the dequeued word.\n    - For each valid word, if it is equal to the endWord, return the distance of the word + 1.\n    - If the word is not visited:\n        - Enqueue the word to the queue.\n        - Add the word to the visited set.\n        - Update the distance of the word in the distance map as distance of the dequeued word + 1.\n5. If we reach here, it means there is no valid transformation sequence, so return 0.\n\nThe BFS algorithm ensures that we explore all possible paths in a breadth-first manner, finding the shortest transformation sequence from beginWord to endWord.", "url": "https://leetcode.com/problems/word-ladder", "commented": false}], "trie": [{"slug": "implement-trie-prefix-tree", "challenge": "A trie (pronounced as 'try') or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings.\nGiven head, the head of a linked list, determine if the linked list has a cycle in it.\nThere are various applications of this data structure, such as autocomplete and spellchecker.\nImplement the Trie class:\nTrie() Initializes the trie object.\nvoid insert(String word) Inserts the string word into the trie.\nboolean search(String word) Returns true if the string word is in the trie (i.e., was inserted before), and false otherwise.\nboolean startsWith(String prefix) Returns true if there is a previously inserted string word that has the prefix prefix, and false otherwise.", "approach": "To implement the Trie class, we can use a combination of a Node class and a Trie class. The Node class will represent each node in the trie, and the Trie class will provide the main functionality of the trie.\n\n1. Create a Node class with the following properties:\n   - A boolean variable, `isEndOfWord`, to indicate whether the node represents the end of a word.\n   - An array of size 26 (for lowercase English alphabets), `children`, to store references to the child nodes.\n\n2. Create a Trie class with the following methods:\n   - Trie(): Initializes the trie object by creating a root node.\n   - insert(String word): Inserts the string word into the trie by traversing the trie and creating new nodes as necessary. Set the `isEndOfWord` property of the last node to true.\n   - search(String word): Returns true if the string word is in the trie by traversing the trie and checking if the `isEndOfWord` property of the last node is true.\n   - startsWith(String prefix): Returns true if there is a previously inserted string word that has the prefix prefix by traversing the trie and checking if all the nodes of the prefix exist.\n\n3. In the Trie class, create a root node in the constructor method to serve as the starting point of the trie.\n\n4. In the Trie class, implement the `insert` method to:\n   - Traverse the trie starting from the root node.\n   - For each character in the word, check if a child node exists for that character.\n   - If a child node exists, move to that node and continue to the next character.\n   - If a child node does not exist, create a new node and set it as the child of the current node, then move to that node and continue to the next character.\n   - After inserting all characters, set the `isEndOfWord` property of the last node to true.\n\n5. In the Trie class, implement the `search` method to:\n   - Traverse the trie starting from the root node.\n   - For each character in the word, check if a child node exists for that character.\n   - If a child node exists, move to that node and continue to the next character.\n   - If a child node does not exist, return false.\n   - After traversing all characters, check if the `isEndOfWord` property of the last node is true. If true, return true; otherwise, return false.\n\n6. In the Trie class, implement the `startsWith` method to:\n   - Traverse the trie starting from the root node.\n   - For each character in the prefix, check if a child node exists for that character.\n   - If a child node exists, move to that node and continue to the next character.\n   - If a child node does not exist, return false.\n   - After traversing all characters, return true.\n\nBy following this approach, we can implement the Trie class with the desired functionality of inserting words into the trie, searching for words in the trie, and checking if there are words in the trie with a given prefix.", "url": "https://leetcode.com/problems/implement-trie-prefix-tree", "commented": false}, {"slug": "word-break", "challenge": "Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words.\nNote that the same word in the dictionary may be reused multiple times in the segmentation.", "approach": "One approach to solve this problem is by using dynamic programming.\n1. Initialize a boolean array dp of length n+1, where dp[i] represents whether the substring s[0:i-1] can be segmented into dictionary words.\n   Initially, set dp[0] to true, as an empty string can be segmented into dictionary words.\n2. Iterate through the string s from index 1 to n (both inclusive).\n3. For each index i, iterate through all previous indices j (from 0 to i-1).\n4. Check if dp[j] is true (meaning that the substring s[0:j-1] can be segmented into dictionary words) and the substring s[j:i] is present in the dictionary.\n   If both conditions are true, set dp[i] to true.\n5. After iterating through all indices i, return dp[n] as the final result. This represents whether the entire string s can be segmented into dictionary words.\n   (n is the length of the string s)\n   \nThe reason for using dynamic programming in this problem is that we can use the solutions to subproblems (whether a substring can be segmented into dictionary words) to solve the overall problem (whether the entire string can be segmented). By breaking the problem into smaller subproblems and storing their solutions, we can avoid redundant calculations and improve the efficiency of the solution.", "url": "https://leetcode.com/problems/word-break", "commented": false}], "linked-list": [{"slug": "merge-two-sorted-lists", "challenge": "You are given the heads of two sorted linked lists list1 and list2.\nMerge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.\nReturn the head of the merged linked list.", "approach": "To merge two sorted linked lists, we can use the following approach:\n\n1. Create a dummy node as the head of the merged linked list.\n2. Initialize two pointers, one for each of the input lists: ptr1 for list1 and ptr2 for list2. Set both pointers to the heads of their respective lists.\n3. Create a pointer, called curr, and initially point it to the dummy node.\n4. Compare the values of ptr1 and ptr2.\n    a. If the value of ptr1 is smaller than or equal to ptr2, set the next node of curr to ptr1. Move ptr1 to the next node in list1.\n    b. Otherwise, set the next node of curr to ptr2. Move ptr2 to the next node in list2.\n5. Move curr to the next node.\n6. Repeat steps 4-5 until either ptr1 or ptr2 becomes null (reached the end of the respective list).\n7. Once one of the pointers becomes null, append the remaining part of the other list to the merged list by setting the next node of curr to the remaining part.\n8. Return the next node of the dummy node as the head of the merged linked list.\n\nThe time complexity of this approach is O(m+n), where m and n are the lengths of list1 and list2 respectively, as we need to iterate through each element once while merging the lists.", "url": "https://leetcode.com/problems/merge-two-sorted-lists", "commented": false}, {"slug": "linked-list-cycle", "challenge": "Given head, the head of a linked list, determine if the linked list has a cycle in it.\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer.\nInternally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.\nReturn true if there is a cycle in the linked list. Otherwise, return false.", "approach": "To determine if a linked list has a cycle, we can use the \"Floyd's cycle detection algorithm\" also known as \"tortoise and hare algorithm\". \n\n1. Initialize two pointers, slow(pointer 1) and fast(pointer 2), both pointing to the head of the linked list.\n2. Iterate through the linked list using the pointers:\n   - Move the slow pointer by one node.\n   - Move the fast pointer by two nodes.\n3. If there is a cycle in the linked list, the fast pointer will eventually meet the slow pointer at some point. If the fast pointer reaches the end of the linked list (i.e., it becomes null), then there is no cycle in the linked list.\n4. Return true if the fast and slow pointers meet (indicating a cycle), otherwise return false.\n\nExplanation: If there is a cycle in the linked list, the fast pointer will eventually catch up to the slow pointer because it moves twice as fast. If there is no cycle, the fast pointer will reach the end of the linked list before the slow pointer.", "url": "https://leetcode.com/problems/linked-list-cycle", "commented": false}, {"slug": "reverse-linked-list", "challenge": "Given the head of a singly linked list, reverse the list, and return the reversed list.", "approach": "To reverse a singly linked list, we need to change the direction of the pointers in each node. The head of the original linked list will become the tail of the reversed linked list.\n\nTo solve this problem, we can use the following approach:\n\n1. Initialize three pointers: prev (points to the previous node), curr (points to the current node), and next (points to the next node).\n\n2. Start with prev = null and curr = head.\n\n3. Iterate through the linked list until curr becomes null:\n   a. Store the next node in the next pointer.\n   b. Update the next pointer of curr to point to the previous node (prev).\n   c. Move prev and curr one step forward by assigning curr to prev and next to curr, respectively.\n\n4. After the loop ends, the prev pointer will be pointing to the last node of the original linked list, which will be the first node of the reversed linked list. Update the head pointer to prev.\n\n5. Return the head of the reversed linked list.\n\nNote: Ensure to handle the case when the input linked list is empty (head is null) or has only one node.", "url": "https://leetcode.com/problems/reverse-linked-list", "commented": false}, {"slug": "middle-of-the-linked-list", "challenge": "Given the head of a singly linked list, return the middle node of the linked list.\nIf there are two middle nodes, return the second middle node.", "approach": "To find the middle node of a linked list, we can use the two-pointer approach. \n\n1. Initialize two pointers, fast and slow, pointing to the head of the linked list.\n2. Move the fast pointer two steps at a time and the slow pointer one step at a time until the fast pointer reaches the end of the linked list. \n3. At this point, the slow pointer will be pointing to the middle node of the linked list.\n\nExplanation:\nBy moving the fast pointer two steps at a time and the slow pointer one step at a time, the fast pointer will reach the end of the linked list when the slow pointer is at the middle node. This is because the fast pointer is moving twice as fast as the slow pointer, so it will take half the time to reach the end of the linked list. Therefore, the slow pointer will be exactly at the middle node.", "url": "https://leetcode.com/problems/middle-of-the-linked-list", "commented": false}, {"slug": "lru-cache", "challenge": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\nImplement the LRUCache class:\nLRUCache(int capacity) Initialize the LRU cache with positive size capacity.\nint get(int key) Return the value of the key if the key exists, otherwise return -1.\nvoid put(int key, int value) Update the value of the key if the key exists.\nOtherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\nThe functions get and put must each run in O(1) average time complexity.", "approach": "Approach:\n1. We can use a combination of a hashmap and a doubly linked list to implement the LRU cache.\n2. The hashmap will store the key-value pairs, where the key will be used to access the corresponding node in the doubly linked list.\n3. The doubly linked list will store the key-value pairs in the order of their usage, with the most recently used key-value pair at the head and the least recently used key-value pair at the tail.\n4. When we get a key, we can check if it exists in the hashmap. If it does, we can move the corresponding node to the head of the doubly linked list and return the value.\n5. When we put a key-value pair, we can check if the key exists in the hashmap. If it does, we can update the value and move the corresponding node to the head of the doubly linked list. If it doesn't, we can add a new node to the head of the doubly linked list and insert the key-value pair into the hashmap.\n6. If the number of keys exceeds the capacity, we need to evict the least recently used key. We can do this by removing the tail node from the doubly linked list and removing the corresponding key from the hashmap.", "url": "https://leetcode.com/problems/lru-cache", "commented": false}], "stack": [{"slug": "valid-parentheses", "challenge": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\nAn input string is valid if:\nOpen brackets must be closed by the same type of brackets.\nOpen brackets must be closed in the correct order.\nEvery close bracket has a corresponding open bracket of the same type", "approach": "To solve this problem, we can use a stack data structure.\n\n1. Initialize an empty stack.\n2. Iterate through each character in the string:\n   a. If the character is an opening bracket ('(', '{', '['), push it onto the stack.\n   b. If the character is a closing bracket (')', '}', ']'), check if the stack is empty. If it is, return False because there is no corresponding opening bracket. Otherwise, pop the top element from the stack and check if it matches the closing bracket. If it doesn't, return False.\n3. After iterating through all characters, check if the stack is empty. If it is, return True because all opening brackets have been matched with corresponding closing brackets. Otherwise, return False because there are unmatched opening brackets.\n\nThis approach works because the stack allows us to keep track of the opening brackets in the correct order. When we encounter a closing bracket, we can easily check if it matches the most recent opening bracket. If it doesn't, then the string is not valid. Additionally, if there are any unmatched opening brackets at the end, the stack will not be empty, indicating that the string is not valid.", "url": "https://leetcode.com/problems/valid-parentheses", "commented": false}, {"slug": "implement-queue-using-stacks", "challenge": "Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty).\nImplement the MyQueue class:\nvoid push(int x) Pushes element x to the back of the queue.\nint pop() Removes the element from the front of the queue and returns it.\nint peek() Returns the element at the front of the queue.\nboolean empty() Returns true if the queue is empty, false otherwise.\nNotes:\nYou must use only standard operations of a stack, which means only push to top, peek/pop from top, size, and is empty operations are valid.\nDepending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack's standard operations.", "approach": "To implement a FIFO queue using only two stacks, we can use one stack to hold the elements in the order they are pushed, and another stack to hold the elements in the reverse order.\n\nHere is the approach:\n\n1. Create two stacks, `stack1` and `stack2`. `stack1` will hold the elements in the order they are pushed, and `stack2` will hold the elements in the reverse order.\n\n2. When `push` operation is called, simply push the element onto `stack1`.\n\n3. When `pop` operation is called, if `stack2` is not empty, pop the top element from `stack2` and return it. If `stack2` is empty, transfer all the elements from `stack1` to `stack2` by popping from `stack1` and pushing onto `stack2`. Then pop the top element from `stack2` and return it.\n\n4. When `peek` operation is called, if `stack2` is not empty, return the top element of `stack2`. If `stack2` is empty, transfer all the elements from `stack1` to `stack2` by popping from `stack1` and pushing onto `stack2`. Then return the top element of `stack2`.\n\n5. When `empty` operation is called, return whether both `stack1` and `stack2` are empty.\n\nThe main idea is to transfer elements from `stack1` to `stack2` when necessary, so that `stack2` always contains the elements in the correct order for FIFO behavior.", "url": "https://leetcode.com/problems/implement-queue-using-stacks", "commented": false}, {"slug": "min-stack", "challenge": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\nImplement the MinStack class:\nMinStack() initializes the stack object.\nvoid push(int val) pushes the element val onto the stack.\nvoid pop() removes the element on the top of the stack.\nint top() gets the top element of the stack.\nint getMin() retrieves the minimum element in the stack.\nYou must implement a solution with O(1) time complexity for each function.", "approach": "To solve this problem, we can use two stacks: one to store the actual elements of the stack, and another to store the minimum element at each step.\n\nHere is the approach:\n\n1. Initialize two stacks: 'stack' and 'minStack'.\n2. When pushing an element onto the stack:\n   a. Push the element onto the 'stack'.\n   b. If 'minStack' is empty or the element is smaller than or equal to the top element of 'minStack', push the element onto 'minStack'.\n3. When popping an element:\n   a. Pop the top element from 'stack'.\n   b. If the popped element is equal to the top element of 'minStack', pop the top element from 'minStack'.\n4. To get the top element of the stack, return the top element of 'stack'.\n5. To retrieve the minimum element in constant time, return the top element of 'minStack'.\n\nBy maintaining the minimum element at each step in a separate stack, we can retrieve it in constant time without having to iterate over the entire stack.", "url": "https://leetcode.com/problems/min-stack", "commented": false}, {"slug": "evaluate-reverse-polish-notation", "challenge": "You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation.\nEvaluate the expression. Return an integer that represents the value of the expression.\nNote that:\nThe valid operators are '+', '-', '*', and '/'.\nEach operand may be an integer or another expression.\nThe division between two integers always truncates toward zero.\nThere will not be any division by zero.\nThe input represents a valid arithmetic expression in a reverse polish notation.\nThe answer and all the intermediate calculations can be represented in a 32-bit integer.", "approach": "Approach:\n1. Iterate through each element in the tokens array.\n2. If the element is an operand (integer), push it onto a stack.\n3. If the element is an operator, pop the last two elements from the stack, perform the operation, and push the result back onto the stack.\n   - For addition: Add the last two elements popped from the stack.\n   - For subtraction: Subtract the second last element popped from the stack from the last element popped from the stack.\n   - For multiplication: Multiply the last two elements popped from the stack.\n   - For division: Divide the second last element popped from the stack by the last element popped from the stack.\n4. Finally, the stack will contain only one element, which is the value of the arithmetic expression. Pop this element and return it as the result.\n\nExplanation: \nThis approach utilizes a stack to keep track of the operands and perform operations when encountering operators. By using Reverse Polish Notation, the order of operations is predetermined, making it easier to evaluate the expression.", "url": "https://leetcode.com/problems/evaluate-reverse-polish-notation", "commented": false}, {"slug": "trapping-rain-water", "challenge": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.", "approach": "Approach:\n1. Create two arrays, left_max and right_max, of size n to store the maximum heights of the bars to the left and right of each index respectively.\n2. Iterate from left to right and fill the left_max array such that left_max[i] stores the maximum height of the bar to the left of index i.\n3. Iterate from right to left and fill the right_max array such that right_max[i] stores the maximum height of the bar to the right of index i.\n4. Iterate over each index and calculate the water trapped at that index by taking the minimum of left_max[i] and right_max[i], subtracting the height of the current bar at that index, and summing them up.\n5. Return the total water trapped.", "url": "https://leetcode.com/problems/trapping-rain-water", "commented": false}, {"slug": "basic-calculator", "challenge": "Given a string s representing a valid expression, implement a basic calculator to evaluate it, and return the result of the evaluation.\nNote: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval().\nConstraints\n1 <= s.length <= 3 * 105\ns consists of digits, '+', '-', '(', ')', and ' '.\ns represents a valid expression.\n'+' is not used as a unary operation (i.e., '+1' and '+(2 + 3)' is invalid).\n'-' could be used as a unary operation (i.e., '-1' and '-(2 + 3)' is valid).\nThere will be no two consecutive operators in the input.\nEvery number and running calculation will fit in a signed 32-bit integer.", "approach": "To solve this problem, we can use the approach of converting the infix expression to postfix expression using the Shunting Yard Algorithm. Once we have the postfix expression, we can evaluate it using a stack.\n\nHere is a step-by-step approach to solve the problem:\n\n1. Initialize an empty stack to store operators and an empty string to store the postfix expression.\n\n2. Iterate through each character in the input string s:\n   - If the character is a space, skip it.\n   - If the character is a digit, append it to the postfix expression.\n   - If the character is an opening parenthesis '(', push it to the stack.\n   - If the character is a closing parenthesis ')':\n     - Pop operators from the stack and append them to the postfix expression until an opening parenthesis '(' is encountered. Pop and discard the opening parenthesis '(' from the stack.\n   - If the character is an operator '+', '-', '*', or '/':\n     - Pop operators from the stack and append them to the postfix expression as long as they have higher or equal precedence than the current operator, and the stack is not empty.\n     - Push the current operator to the stack.\n\n3. After iterating through all characters in the input string, pop any remaining operators from the stack and append them to the postfix expression.\n\n4. Initialize an empty stack to store operands.\n\n5. Iterate through each character in the postfix expression:\n   - If the character is a digit, convert it to an integer and push it to the operand stack.\n   - If the character is an operator, pop two operands from the operand stack, perform the operation, and push the result back to the operand stack.\n\n6. Finally, the result of the expression will be the top element of the operand stack.\n\nNote: In step 2, when pushing an operator to the stack, we need to consider the precedence of the operators. For example, '*' and '/' have higher precedence than '+' and '-', so we should pop operators with higher or equal precedence from the stack. Also, when performing the operations in step 5, we should consider the order of operations (e.g., multiplying or dividing before adding or subtracting).", "url": "https://leetcode.com/problems/basic-calculator", "commented": false}, {"slug": "largest-rectangle-in-histogram", "challenge": "Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.", "approach": "One possible approach to solve this problem is to use a stack.\n\n1. Create an empty stack to store the indices of the bars in the histogram.\n\n2. Iterate through each bar in the histogram:\n\n   a. While the stack is not empty and the current bar is smaller than the bar at the top of the stack, do the following:\n   \n      - Pop the index from the stack, representing the bar with a height greater than or equal to the current bar.\n      \n      - Calculate the area of the rectangle that can be formed using the popped bar as the smallest bar:\n        - If the stack is empty, the width of the rectangle would be the current index (i.e., the current bar) since all the previous bars popped from the stack were smaller than the current bar.\n        - If the stack is not empty, the width of the rectangle would be the difference between the current index and the index at the top of the stack minus 1, as all the bars between these two indices are shorter than the popped bar.\n        \n      - Update the maximum area if the area of the rectangle currently calculated is greater than the maximum area.\n   \n   b. Push the current index onto the stack.\n   \n3. After iterating through all the bars in the histogram, if there are any remaining bars in the stack, perform step 2a for each remaining index in the stack to calculate the area of the rectangles formed using the remaining bars as the smallest bar.\n\n4. Return the maximum area calculated throughout the process.\n\nThis approach utilizes the concept of a monotonically increasing stack. By maintaining a stack of indices such that the array values at those indices are in non-decreasing order, we can efficiently calculate the area of the largest rectangle in the histogram by considering the bars as the smallest bar in the possible rectangles.", "url": "https://leetcode.com/problems/largest-rectangle-in-histogram", "commented": false}], "recursion": [{"slug": "permutations", "challenge": "Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.", "approach": "One approach to solve this problem is to use backtracking. \n\nHere are the steps:\n\n1. Create a helper function, backtrack, that takes the current permutation, the array of numbers, a boolean array to keep track of visited numbers, and a result list to store all the permutations.\n2. Check if the current permutation has the same length as the input array. If it does, add the permutation to the result list and return.\n3. Otherwise, iterate through the array of numbers.\n4. For each number that has not been visited yet, mark it as visited.\n5. Add the current number to the current permutation.\n6. Recursively call the backtrack function with the updated current permutation, the updated visited array, and the result list.\n7. After the recursive call, remove the last number from the current permutation and mark the current number as unvisited.\n8. Repeat steps 4 to 7 until all numbers have been visited.\n9. In the main function, initialize the visited array as a boolean array of length n (the size of the input array) filled with false.\n10. Call the backtrack function with an empty current permutation, the input array, the visited array, and an empty result list.\n11. Return the result list as the output.", "url": "https://leetcode.com/problems/permutations", "commented": false}, {"slug": "subsets", "challenge": "Given an integer array nums of unique elements, return all possible subsets (the power set).\nThe solution set must not contain duplicate subsets. Return the solution in any order.", "approach": "To solve this problem, we can use a recursive backtracking approach.\n\n1. Create an empty list to store the subsets.\n2. Initialize an empty list to store the current subset.\n3. Call a recursive function to generate subsets, passing in the current subset, the input array, and the index of the current element.\n4. In the recursive function:\n    a. Append the current subset to the list of subsets.\n    b. Iterate through the input array starting from the current index:\n        i. Add the current element to the current subset.\n        ii. Recursively call the function with the updated current subset and the next index.\n        iii. Remove the current element from the current subset (backtracking).\n5. Return the list of subsets.\n\nThe recursive backtracking approach is used to generate all possible combinations of elements in the array by including or excluding each element at each recursive call. By adding the current subset to the list of subsets before each recursive call, we ensure that all combinations are captured. Backtracking is used to remove the current element from the subset after each recursive call, allowing us to explore different combinations.", "url": "https://leetcode.com/problems/subsets", "commented": false}, {"slug": "letter-combinations-of-a-phone-number", "challenge": "Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.\nA mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.", "approach": "One possible approach to solve this problem is to use backtracking. \n\n1. First, create a mapping of digits to letters. You can use a dictionary or an array for this.\n2. Define a recursive helper function that takes three parameters: the current combination, the index indicating the current digit in the input string, and the final list to store the result.\n3. In the helper function, check if the index is equal to the length of the input string. If it is, add the current combination to the final list and return.\n4. If the index is less than the length of the input string, get the digit at the current index.\n5. Get the corresponding letters for the current digit from the mapping.\n6. Iterate through the letters and append each letter to the current combination.\n7. Call the helper function recursively with the updated combination and the next index.\n8. After the recursive call returns, remove the last letter from the combination to backtrack.\n9. Repeat steps 6-8 for each letter in the current digit.\n10. Finally, initialize an empty final list and call the helper function with an empty combination and index 0.\n11. Return the final list of all possible letter combinations.\n\nThe use of backtracking allows us to explore all possible combinations by building the combination one letter at a time and removing the last letter to backtrack and try a different letter.", "url": "https://leetcode.com/problems/letter-combinations-of-a-phone-number", "commented": false}], "heap": [{"slug": "k-closest-points-to-origin", "challenge": "Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0).\nThe distance between two points on the X-Y plane is the Euclidean distance (i.e., \u00e2\u02c6\u0161(x1 - x2)2 + (y1 - y2)2).\nYou may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in).", "approach": "Approach:\n1. Calculate the distance of each point from the origin using the Euclidean distance formula.\n2. Store the distance and the corresponding point in a min-heap data structure.\n3. While inserting the points into the min-heap, ensure that the heap has a maximum size of k to maintain only the k closest points.\n4. After inserting all the points into the min-heap, the k closest points will be the top k elements of the heap.\n5. Return these k closest points as the result.", "url": "https://leetcode.com/problems/k-closest-points-to-origin", "commented": false}, {"slug": "task-scheduler", "challenge": "Given a characters array tasks, representing the tasks a CPU needs to do, where each letter represents a different task.\nTasks could be done in any order. Each task is done in one unit of time.\nFor each unit of time, the CPU could complete either one task or just be idle.\n However, there is a non-negative integer n that represents the cooldown period between two same tasks (the same letter in the array), that is that there must be at least n units of time between any two same tasks.\nReturn the least number of units of times that the CPU will take to finish all the given tasks.", "approach": "To solve this problem, we can use a greedy approach. \n1. First, calculate the frequency of each task.\n2. Sort the frequencies in descending order, so that the task with the highest frequency comes first.\n3. Initialize a variable called 'maxFreq' to store the maximum frequency of any task.\n4. Iterate through the frequencies. For each frequency, do the following:\n   - Calculate how many idle slots are needed before the current task can be executed.\n   - If the idle slots needed are greater than the number of available idle slots, update the number of idle slots.\n   - Update the 'maxFreq' if the current task's frequency is equal to 'maxFreq'.\n5. Finally, return the minimum number of slots required, which can be calculated as the total number of tasks plus the number of idle slots.", "url": "https://leetcode.com/problems/task-scheduler", "commented": false}, {"slug": "find-median-from-data-stream", "challenge": "The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values\nFor example, for arr = [2,3,4], the median is 3.\nFor example, for arr = [2,3], the median is (2 + 3) / 2 = 2.5.\nImplement the MedianFinder class:\nMedianFinder() initializes the MedianFinder object.\nvoid addNum(int num) adds the integer num from the data stream to the data structure.\ndouble findMedian() returns the median of all elements so far.\nAnswers within 10-5 of the actual answer will be accepted.", "approach": "Approach:\n1. Initialize two heaps: a max heap called \"low\" to store the smaller half of the numbers, and a min heap called \"high\" to store the larger half of the numbers.\n2. When adding a number, check which heap is smaller. If both heaps are empty or the number is smaller than the root of \"low\", add it to \"low\". Otherwise, add it to \"high\".\n3. After adding the number, check the size of the heaps. If the size difference is greater than 1, balance the heaps by removing the top element from the larger heap and adding it to the smaller heap.\n4. To find the median, check the sizes of the heaps. If the sizes are equal, calculate the average of the roots of both heaps. If the size difference is 1, return the root of the larger heap.\n5. The time complexity of adding a number is O(log n), and the time complexity of finding the median is O(1).\n6. The space complexity is O(n) to store the numbers.", "url": "https://leetcode.com/problems/find-median-from-data-stream", "commented": false}, {"slug": "merge-k-sorted-lists", "challenge": "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\nMerge all the linked-lists into one sorted linked-list and return it.", "approach": "Approach:\n1. Initialize a variable `result` as null.\n2. If the input array `lists` is empty, return `result`.\n3. Initialize a priority queue `pq` to store the heads of each linked list.\n4. Iterate through each linked list in `lists` and insert the head node of each linked list into `pq`.\n5. While `pq` is not empty:\n   - Remove the node with the smallest value from `pq`. Let's call this node `current`.\n   - Add `current` to the result linked list by setting its `next` pointer to `null` (since we don't yet know which node should be its next).\n   - If `current` has a next node, insert the next node into `pq`.\n6. Return the head of the result linked list.\n\nExplanation:\n- By using a priority queue, we can always get the smallest value among the heads of the linked lists.\n- We merge the linked lists by continuously connecting the smallest node with the next smallest node until all the nodes are merged into a single sorted linked list.\n- This approach has a time complexity of O(N log k), where N is the total number of nodes across all linked lists and k is the number of linked lists.", "url": "https://leetcode.com/problems/merge-k-sorted-lists", "commented": false}], "binary": [{"slug": "add-binary", "challenge": "Given two binary strings a and b, return their sum as a binary string.", "approach": "Approach:\n\n1. Take two pointers, one for string a and one for string b, starting from the rightmost digit of each string.\n2. Initialize a carry variable to 0.\n3. Initialize an empty string to store the result.\n4. Iterate over the strings from right to left until both pointers reach the beginning of the strings.\n   a. Convert the current digits at the pointers to integers.\n   b. Add the digits, along with the carry.\n   c. If the sum is 2 or 3, set the carry to 1.\n   d. Otherwise, set the carry to 0.\n   e. Append the sum modulo 2 to the result string.\n   f. Move both pointers to the left.\n5. After the iteration, if there is a carry left, append it to the result string.\n6. Reverse the result string.\n7. Return the result string as the sum of the two binary strings.\n\nExplanation:\n- By iterating from right to left, we can perform the addition digit by digit, starting from the ones place and moving towards the higher place values.\n- If the sum of two digits is 2 or 3 in binary, we need to carry over the 1 to the next higher place value.\n- The result string is initialized empty because we will be appending the binary digits to it starting from the rightmost place value.", "url": "https://leetcode.com/problems/add-binary", "commented": false}], "hash-table": [{"slug": "ransom-note", "challenge": "Given two strings ransomNote and magazine, return true if ransomNote can be constructed by using the letters from magazine and false otherwise.\nEach letter in magazine can only be used once in ransomNote.", "approach": "To solve this problem, we can use a hashmap to store the frequency of each character in the magazine string. Then, we iterate through the ransomNote string and check if each character exists in the hashmap and has a non-zero frequency. If it does, we decrement the frequency in the hashmap, indicating that we have used that character. If at any point we encounter a character that is not in the hashmap or has a zero frequency, we return false. If we successfully iterate through all characters in the ransomNote string, we return true.\n\nThis approach has a time complexity of O(m + n), where m and n are the lengths of the ransomNote and magazine strings respectively. This is because we iterate through both strings once to build the hashmap and check if each character is in the hashmap.", "url": "https://leetcode.com/problems/ransom-note", "commented": false}], "binary-search": [{"slug": "binary-search", "challenge": "Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums.\nIf target exists, then return its index. Otherwise, return -1.\nYou must write an algorithm with O(log n) runtime complexity.", "approach": "To solve this problem, we can use a modified version of binary search. \n\n1. Set two pointers, \"left\" and \"right\", at the start and end of the array respectively.\n2. While left <= right:\n     3. Calculate the middle index as (left + right) / 2.\n     4. If the middle element is equal to the target, return the middle index.\n     5. If the middle element is greater than the target, update the right pointer to be middle - 1.\n     6. If the middle element is less than the target, update the left pointer to be middle + 1.\n7. If the target is not found after the while loop, return -1.\n\nThe runtime complexity of this approach is O(log n) since we repeatedly divide the search space in half with each iteration of the binary search.", "url": "https://leetcode.com/problems/binary-search", "commented": false}, {"slug": "first-bad-version", "challenge": "You are a product manager and currently leading a team to develop a new product.\nUnfortunately, the latest version of your product fails the quality check.\nSince each version is developed based on the previous version, all the versions after a bad version are also bad.\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\nYou are given an API bool isBadVersion(version) which returns whether version is bad.\nImplement a function to find the first bad version. You should minimize the number of calls to the API.", "approach": "To solve this problem, we can use a binary search approach. \n\n1. Set the lower bound as 1 and the upper bound as n.\n2. Repeat the following steps until the lower bound is less than or equal to the upper bound:\n   a. Calculate the middle version as the average of the lower bound and upper bound: middle = (lower + upper) / 2.\n   b. Check if the middle version is a bad version using the isBadVersion API.\n   c. If the middle version is a bad version, then all versions after it are also bad. Set the upper bound as middle - 1.\n   d. If the middle version is not a bad version, then all versions before it are not bad. Set the lower bound as middle + 1.\n3. At the end of the loop, the lower bound will be pointing to the first bad version.\n4. Return the lower bound as the answer.\n\nThe binary search approach allows us to find the first bad version by efficiently dividing the search space in half at each step. This minimizes the number of calls to the isBadVersion API by narrowing down the search range.", "url": "https://leetcode.com/problems/first-bad-version", "commented": false}, {"slug": "search-in-rotated-sorted-array", "challenge": "There is an integer array nums sorted in ascending order (with distinct values).\nPrior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed).\nFor example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].\nGiven the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.\nYou must write an algorithm with O(log n) runtime complexity.", "approach": "Approach:\n1. Perform a modified binary search to find the smallest element in the rotated sorted array. This gives us the pivot index.\n2. Check if the target is the smallest element itself or if it lies in the left half or the right half of the array based on the pivot index.\n3. Perform a regular binary search in the appropriate half of the array to find the target element.", "url": "https://leetcode.com/problems/search-in-rotated-sorted-array", "commented": false}, {"slug": "time-based-key-value-store", "challenge": "Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key's value at a certain timestamp\nImplement the TimeMap class:\nTimeMap() Initializes the object of the data structure.\nvoid set(String key, String value, int timestamp) Stores the key key with the value value at the given time timestamp.\nString get(String key, int timestamp) Returns a value such that set was called previously, with timestamp_prev <= timestamp.\nIf there are multiple such values, it returns the value associated with the largest timestamp_prev.\nIf there are no values, it returns '.'", "approach": "Approach:\n1. Create a HashMap to store the key-value pairs, where the key is the key string and the value is a list of timestamp-value pairs.\n2. Each timestamp-value pair can be represented as a custom class or a tuple.\n3. When set() is called, add the timestamp-value pair to the list of the corresponding key in the HashMap.\n4. When get() is called, retrieve the list of timestamp-value pairs for the given key from the HashMap.\n5. Iterate through the list in reverse order (from the latest timestamp to the earliest) and return the value of the first timestamp that is less than or equal to the given timestamp.\n6. If no such timestamp is found, return '.' to indicate no value is available.", "url": "https://leetcode.com/problems/time-based-key-value-store", "commented": false}, {"slug": "maximum-profit-in-job-scheduling", "challenge": "We have n jobs, where every job is scheduled to be done from startTime[i] to endTime[i], obtaining a profit of profit[i].\nYou're given the startTime, endTime and profit arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.\nIf you choose a job that ends at time X you will be able to start another job that starts at time X.", "approach": "To solve this problem, we can use a dynamic programming approach. Here is the approach:\n\n1. First, sort the jobs based on their endTime in ascending order. This will ensure that we process the jobs in a sequential manner, considering the ones with earlier end times first.\n\n2. Create an array, dp, of size n+1, where dp[i] represents the maximum profit that can be obtained by considering the first i jobs.\n\n3. Initialize dp[0] to be 0, as there are no jobs to consider.\n\n4. For each job i (starting from index 1):\n\n   - Find the index j (0 <= j < i) such that endTime[j] <= startTime[i] and dp[j] + profit[i] is maximum. This means that we are considering the maximum profit obtained by including job i and all the previous jobs that end before the start of job i.\n   \n   - Update dp[i] to be dp[j] + profit[i].\n   \n   - Update dp[i] to be the maximum between dp[i] and dp[i-1]. This takes into account the scenario where job i is skipped, and we consider the maximum profit obtained by considering all the previous jobs.\n   \n5. Finally, return dp[n], which represents the maximum profit that can be obtained by considering all the jobs.\n\nThe time complexity of this approach is O(n^2) because of the nested loop to find the proper index j. However, this can be optimized to O(n log n) by using binary search or by using a TreeMap data structure to efficiently find the index j.", "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling", "commented": false}], "array": [{"slug": "two-sum", "challenge": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nYou can return the answer in any order", "approach": "Approach:\n1. Create an empty dictionary to store the seen numbers and their indices.\n2. Iterate through the array.\n3. For each number, calculate the complement by subtracting it from the target.\n4. Check if the complement exists in the dictionary. If it does, return the indices of the current number and its complement.\n5. If the complement does not exist in the dictionary, add the current number and its index to the dictionary.\n6. If no solution is found, return an empty array.\n\nExplanation:\nBy using a dictionary, we can store the seen numbers and their indices in constant time. This allows us to quickly check if a complement exists in the dictionary and find the solution in linear time. Using a dictionary also ensures that we do not use the same number twice, as the complement cannot be the same as the current number.", "url": "https://leetcode.com/problems/two-sum", "commented": true}, {"slug": "best-time-to-buy-and-sell-stock", "challenge": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.", "approach": "Approach:\n1. Initialize two variables, minPrice to track the minimum price of the stock so far and maxProfit to track the maximum profit so far.\n2. Iterate through the array of prices.\n3. For each price, check if it is smaller than the current minPrice. If it is, update minPrice.\n4. If the price minus the minPrice is greater than the current maxProfit, update maxProfit.\n5. Finally, return the maxProfit.", "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock", "commented": true}, {"slug": "majority-element", "challenge": "Given an array nums of size n, return the majority element.\nThe majority element is the element that appears more than \u00e2\u0152\u0160n / 2\u00e2\u0152\u2039 times.\nYou may assume that the majority element always exists in the array.", "approach": "One approach to solve this problem is by using the Boyer-Moore Voting Algorithm. \n\n1. Initialize a variable called \"count\" to 0 and another variable called \"candidate\" to None. \n   The count variable will keep track of the number of occurrences of the majority element, \n   and the candidate variable will represent our current guess for the majority element.\n\n2. Iterate through the array. For each element:\n   - If the count is 0, assign the current element to the candidate variable.\n   - If the current element is the same as the candidate, increment the count by 1.\n   - If the current element is different from the candidate, decrement the count by 1.\n\n   The idea behind this algorithm is that the majority element appears more than n/2 times. \n   So, even if all other elements \"vote\" for themselves, the majority element will win \n   because it has the highest count.\n\n3. Return the candidate variable, which should be the majority element.\n\nThis algorithm has a time complexity of O(n) and a space complexity of O(1).", "url": "https://leetcode.com/problems/majority-element", "commented": true}, {"slug": "contains-duplicate", "challenge": "Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.", "approach": "To solve this problem, we can use a hash set to keep track of the elements we have seen so far while iterating through the array. \n\nHere is the approach:\n1. Initialize an empty hash set.\n2. Iterate through each element in the array.\n3. For each element, check if it is already in the hash set.\n   - If it is, return true as we have encountered a duplicate element.\n   - If it is not, add the element to the hash set.\n4. If we finish iterating through the array without finding any duplicates, return false.", "url": "https://leetcode.com/problems/contains-duplicate", "commented": true}, {"slug": "insert-interval", "challenge": "You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval.\nintervals is sorted in ascending order by starti.\nYou are also given an interval newInterval = [start, end] that represents the start and end of another interval.\nInsert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).\nReturn intervals after the insertion.", "approach": "One approach to solve this problem is as follows:\n\n1. Create an empty result list to store the merged intervals.\n2. Iterate through each interval in the given intervals array.\n3. If the end of the current interval is less than the start of the newInterval, add the current interval to the result list.\n4. If the start of the current interval is greater than the end of the newInterval, add the newInterval and all remaining intervals to the result list.\n5. If the current interval overlaps with the newInterval, update the newInterval by taking the minimum of its start with the start of the current interval, and the maximum of its end with the end of the current interval.\n6. After iterating through all intervals, add the newInterval to the result list.\n7. Return the result list as the merged intervals.", "url": "https://leetcode.com/problems/insert-interval", "commented": false}, {"slug": "3sum", "challenge": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\nNotice that the solution set must not contain duplicate triplets.", "approach": "Approach:\n\n1. Sort the given array `nums` in ascending order. Sorting the array will make it easier to find triplets that add up to zero.\n2. Initialize an empty result list to store the unique triplets.\n3. Iterate through the sorted array from index `i=0` to `n-3` (where `n` is the length of `nums`).\n4. If `i > 0` and `nums[i]` is equal to `nums[i-1]`, continue to the next iteration. This step is to avoid duplicate triplets.\n5. Initialize two pointers `left` and `right` at indices `i+1` and `n-1` respectively.\n6. While `left < right`, check if `nums[i] + nums[left] + nums[right]` equals zero. If so, add the triplet `[nums[i], nums[left], nums[right]]` to the result list.\n7. If the sum is less than zero, increment `left` by 1 to move towards larger values.\n8. If the sum is greater than zero, decrement `right` by 1 to move towards smaller values.\n9. If the sum is equal to zero, increment `left` by 1 and decrement `right` by 1 to find other possible triplet combinations.\n10. If `nums[i] + nums[left] + nums[right]` is less than zero, increment `left` by 1 to avoid duplicate triplets.\n11. If `nums[i] + nums[left] + nums[right]` is greater than zero, decrement `right` by 1 to avoid duplicate triplets.\n12. Repeat steps 6 to 11 until `left` is less than `right`.\n13. Repeat steps 4 to 12 until `i` is less than `n-2`.\n14. Finally, return the result list of unique triplets that add up to zero.", "url": "https://leetcode.com/problems/3sum", "commented": false}, {"slug": "product-of-array-except-self", "challenge": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\nYou must write an algorithm that runs in O(n) time and without using the division operation.", "approach": "To solve this problem without using the division operation, we can use the concept of prefix and suffix products. First, we initialize an empty array called 'answer' to store the result. Then, we calculate the prefix products of the input array 'nums' and store them in the 'answer' array. Each element in the 'answer' array represents the product of all elements on the left side of the corresponding index in 'nums'.\n\nNext, we traverse the 'nums' array in reverse order and calculate the suffix products. We keep track of the product of all elements on the right side of each index and multiply it with the corresponding element in the 'answer' array. This will give us the product of all elements except nums[i] for each i.\n\nFinally, we return the 'answer' array which contains the desired result. This algorithm has a time complexity of O(n) because we loop through the 'nums' array twice, once for calculating prefix products and once for calculating suffix products.", "url": "https://leetcode.com/problems/product-of-array-except-self", "commented": false}, {"slug": "combination-sum", "challenge": "Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target.\nYou may return the combinations in any order.\nThe same number may be chosen from candidates an unlimited number of times.\nTwo combinations are unique if the frequency of at least one of the chosen numbers is different.\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.", "approach": "One approach to solve this problem is by using backtracking.\n\n1. Sort the candidates array in ascending order to easily eliminate duplicates and stop recursion if a certain candidate value exceeds the target value.\n\n2. Create an empty result list to store the unique combinations.\n\n3. Define a helper function, backtrack, that takes four parameters: current combination, current sum, starting index, and target.\n\n4. In the helper function, check if the current sum is equal to the target. If it is, add the current combination to the result list.\n\n5. If the current sum is greater than the target, return to stop further recursion.\n\n6. Iterate over the candidates array starting from the starting index. For each candidate, add it to the current combination and update the current sum.\n\n7. Recursively call the helper function, but pass the starting index as the current index to avoid using the same candidates multiple times.\n\n8. After the recursive call, remove the last candidate from the current combination and subtract its value from the current sum.\n\n9. Repeat steps 6-8 until all candidates have been considered.\n\n10. Finally, call the helper function with an empty current combination, 0 as the current sum, and 0 as the starting index.\n\n11. Return the result list.", "url": "https://leetcode.com/problems/combination-sum", "commented": false}, {"slug": "merge-intervals", "challenge": "Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.", "approach": "Approach:\n\n1. Sort the intervals based on the start time, so that we can merge overlapping intervals efficiently.\n2. Initialize an empty list called \"merged\".\n3. Iterate through the sorted intervals:\n   - If the current interval overlaps with the last interval in the \"merged\" list, merge them by updating the end time of the last interval in \"merged\".\n   - If the current interval doesn't overlap, add it to the \"merged\" list.\n4. Return the \"merged\" list as the result.\n\nExplanation:\nSorting the intervals allows us to easily merge overlapping intervals. By comparing the end time of the last interval in the merged list with the start time of the current interval, we can determine if they overlap. If they do, we update the end time of the last interval to the maximum of the current interval's end time and the existing end time. If they don't overlap, we simply add the current interval to the merged list. This approach ensures that all overlapping intervals are merged, resulting in non-overlapping intervals.", "url": "https://leetcode.com/problems/merge-intervals", "commented": true}, {"slug": "sort-colors", "challenge": "Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\nWe will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.\nYou must solve this problem without using the library's sort function.", "approach": "One approach to solve this problem is known as the \"Dutch National Flag algorithm\". \n\nThe basic idea is to maintain three pointers, \"low\", \"mid\", and \"high\" to keep track of the boundaries between the three colors. Initially, \"low\" and \"mid\" are set to the start of the array, and \"high\" is set to the end of the array. \n\nWe can iterate through the array using a while loop and check the color of the current element at the \"mid\" pointer. If it is red (0), we swap it with the element at the \"low\" pointer and increment both \"low\" and \"mid\". If it is white (1), we increment only the \"mid\" pointer. If it is blue (2), we swap it with the element at the \"high\" pointer and decrement the \"high\" pointer. \n\nBy doing this, we maintain the following conditions:\n- All elements to the left of the \"low\" pointer are red (0).\n- All elements between the \"low\" and \"mid\" pointers are white (1).\n- All elements to the right of the \"high\" pointer are blue (2).\n\nAs we iterate through the array and swap elements, the array becomes sorted in place according to the desired order.\n\nThe one-line explanation for why we increment or decrement the pointers is that we are moving the elements that are already sorted (e.g., red elements to the left, blue elements to the right) towards their correct positions, while keeping the unsorted elements (white) in the middle to be processed later.", "url": "https://leetcode.com/problems/sort-colors", "commented": true}, {"slug": "container-with-most-water", "challenge": "You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\nReturn the maximum amount of water a container can store.\nNotice that you may not slant the container.", "approach": "We can solve this problem using the Two Pointer approach.\n1. Initialize two pointers, left = 0 and right = n - 1, pointing to the start and end of the array respectively.\n2. While the left pointer is less than the right pointer:\n   - Calculate the area of the container using the formula: (right - left) * min(height[left], height[right])\n   - Update the maximum area if the calculated area is greater than the current maximum area.\n   - Move the pointer with the smaller height inward, i.e., if height[left] < height[right], increment left by 1. Otherwise, decrement right by 1.\n3. Return the maximum area obtained.\n\nExplanation: \nBy using two pointers starting from both ends of the array, we consider all possible containers. Initially, the width between the pointers is maximum. We then move the pointer with the smaller height inward, as a wider container will not result in a larger area. By moving the pointer with the smaller height, we have a chance of finding a taller height that could potentially yield a larger area. This approach ensures that we explore all possible container configurations with a linear time complexity.", "url": "https://leetcode.com/problems/container-with-most-water", "commented": true}]}